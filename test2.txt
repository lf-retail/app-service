---
- name: Stop WAS
  become: true
  become_user: "{{ ansible_user }}"
  ignore_errors: yes
  shell:
    cmd: |
      /ibm/IBM/WebSphere/AppServer/profiles/AppSrv01/bin/stopServer.sh BPMMBR01 &&
      /ibm/IBM/WebSphere/AppServer/profiles/AppSrv01/bin/stopNode.sh
      #/ibm/IBM/WebSphere/AppServer/profiles/AppSrv01/bin/stopServer.sh -username deployer -password deployer@123 BPMMBR01 --connect controller=10.15.11.209 command=:shutdown &&
      #/ibm/IBM/WebSphere/AppServer/profiles/AppSrv01/bin/stopNode.sh -username deployer -password deployer@123 --connect controller=10.15.11.209 command=:shutdown

#- name: Create directory for new release version
 # file:
  #  path: "{{ Profile_home }}/release.{{ release_version }}"
   # state: directory
    #mode: '0755'

- name: Copy war-install-in-was1.sh to Target Server
  become: yes
  become_user: "{{ ansible_user }}"
  copy:
    src: "/ansible/GITHUB_RUNNER/actions-runner10/_work/ibps-was-ansible-cd/ibps-was-ansible-cd/war-install-in-was1.sh"
    dest: "{{ Profile_home }}/release.{{ release_version }}/war-install-in-was1.sh"
    mode: '0755'

- name: Run war-install-in-was1.sh on Target Server
  become: yes
  become_user: "{{ ansible_user }}"
  ignore_errors: yes
  shell: "cd {{ Profile_home }}/release.{{ release_version }} && ./war-install-in-was1.sh ibps_library omnidocs_library wfs_library od_library"
  register: deploy_result

- name: Start WAS
  become: true
  become_user: "{{ ansible_user }}"
  shell:
    cmd: |
      /ibm/IBM/WebSphere/AppServer/profiles/AppSrv01/bin/startNode.sh &&
      /ibm/IBM/WebSphere/AppServer/profiles/AppSrv01/bin/startServer.sh BPMMBR01

=============

#!/bin/bash

# Server details (adapt these variables to your environment)
WAS_HOST="10.15.11.209"
WAS_PORT="9043" # Change to your WAS administrative port, often 9043 for HTTPS
WAS_ADMIN_USER="deployer"
WAS_ADMIN_PASSWORD="deployer@123"

# WAR file and application details
WAR_FILE_PATH="/ibm/IBM/WebSphere/AppServer/profiles/AppSrv01/installedApps/antibpsapp1Cell01/KYC_Remediation.war"
APP_NAME="KYC_Remediation"
CONTEXT_ROOT="KYC_Remediation"

# Combine all shared libraries into a single string
SHARED_LIB=$(printf ",%s" "$@")
SHARED_LIB=${SHARED_LIB:1} # Remove the leading comma

# Path to wsadmin.sh (adjust for your WAS installation)
WSADMIN="/ibm/IBM/WebSphere/AppServer/profiles/AppSrv01/bin/wsadmin.sh"

# wsadmin script content
WSADMIN_SCRIPT="
# Connect to WebSphere Application Server
AdminConfig.connect('$WAS_ADMIN_USER', '$WAS_ADMIN_PASSWORD')

# Check if the application already exists
if AdminApp.list().find('$APP_NAME') != -1:
    print('Application $APP_NAME already exists. Skipping installation.')
else:
    # Install the application with Parent Last class loader policy
    AdminApp.install('$WAR_FILE_PATH', '[ -appname $APP_NAME -contextroot $CONTEXT_ROOT -MapModulesToServers [[ .* .* WebSphere:cell=YourCellName,node=YourNodeName,server=YourServerName ]] -MapWebModToVH [[ .* .* default_host ]] -classloaderMode PARENT_LAST ]')
    # Install the application
    #AdminApp.install('$WAR_FILE_PATH', '[ -appname $APP_NAME -contextroot $CONTEXT_ROOT -MapWebModToVH [[ .* .* default_host ]] ]')
    # Map shared libraries (Optional: Adjust or remove according to your requirements)
    AdminConfig.create('LibraryRef', AdminConfig.getid('/Deployment:$APP_NAME/'), '[[libraryName $SHARED_LIB]]')
    # Save configuration changes
    AdminConfig.save()

# Disconnect from the server
AdminConfig.disconnect()
"

# Check if shared libraries were provided
if [ -z "$SHARED_LIB" ]; then
    echo "No shared libraries provided. Deployment failed."
    exit 1
fi

# Execute the script with wsadmin
echo "Deploying $APP_NAME from WAR file: $WAR_FILE_PATH"
echo "$WSADMIN_SCRIPT" | $WSADMIN -lang jython -conntype SOAP -host $WAS_HOST -port $WAS_PORT -user $WAS_ADMIN_USER -password $WAS_ADMIN_PASSWORD

if [ $? -eq 0 ]; then
    echo "Deployment of $APP_NAME completed successfully."
else
    echo "Deployment failed. Check the output for errors."
    exit 1
fi
