#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

# Use unzip with -u option to update existing files
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home"

# List files after extraction in the specified path
ls -la "$Profile_home/release/"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    targeted_location="{{ targeted_location }}"
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if both app_name and app_targeted_location are not empty
        if [ -n "$app_name" ] && [ -n "$app_targeted_location" ]; then
            # Backup timestamp
            backup_timestamp=$(date +'%Y%m%d%H%M%S')

            # Construct paths for old deployment files and backup location
            old_deployment_path="$targeted_location/$app_targeted_location"
            backup_path="$backup_location/$app_name-$backup_timestamp"

            # Move old deployment files to backup location
            mv "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"
            
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
======================

Hi Gaurav/Suresh,

We are developing the CD part for the application of IBPS and we need support for verification . As we discussed I am scheduling the meeting tomorrow at 4pm.

Thanks,
Shanmuganathan M.

Gaurav.Kumar@rakbank.ae
Suresh.Shanmugam@rakbank.ae
====================

ofme_ejb.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell

newgenapp_jar.ear
=================================


#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

# Use unzip with -u option to update existing files
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home"

# List files after extraction in the specified path
ls -la "$Profile_home/release/"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    targeted_location="{{ targeted_location }}"
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Backup timestamp
            backup_timestamp=$(date +'%Y%m%d%H%M%S')

            # Construct paths for old deployment files and backup location
            old_deployment_path="$targeted_location/$app_targeted_location"
            backup_path="$backup_location/$app_name-$backup_timestamp"

            # Move old deployment files to backup location
            mv "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"
            
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
===========================

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

# Use unzip with -u option to update existing files
echo "Trying to unzip $Profile_home/$zip_file_name to $Profile_home"
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home"
unzip_exit_code=$?

# Print the exit code of unzip
echo "Unzip Exit Code: $unzip_exit_code"

# List files after extraction in the specified path
ls -la "$Profile_home/release/"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Rest of your script...
=========

    "stdout_lines": [
        "Profile_home: /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin",
        "zip_file_url: https://maven.pkg.github.com/rakbank-internal/ibps-was-ansible-cd/Rak/IBPS/release/1.0.0.2/release-1.0.0.2.zip",
        "zip_file_name: release-1.0.0.2.zip",
        "8.0K\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/sdk",
        "28K\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/temp_directory/release/newgenapp_jar.ear/META-INF",
        "76K\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/temp_directory/release/newgenapp_jar.ear",
        "84K\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/temp_directory/release",
        "88K\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/temp_directory",
        "20K\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release/ofme_ejb.ear/META-INF",
        "356K\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release/ofme_ejb.ear",
        "28K\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release/newgenapp_jar.ear/META-INF",
        "76K\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release/newgenapp_jar.ear",
        "440K\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release",
        "6.3M\t/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin"
    ]

====

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

du -h "$Profile_home"


==========

unzip -uq -P 4 "$Profile_home/$zip_file_name" -d "$Profile_home"

df -h
===============================

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

# Use unzip with -u option to update existing files
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home"

# List files after extraction in the specified path
ls -la "$Profile_home/release/"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    targeted_location="{{ targeted_location }}"
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Backup timestamp
            backup_timestamp=$(date +'%Y%m%d%H%M%S')

            # Construct paths for old deployment files and backup location
            old_deployment_path="$targeted_location/$app_targeted_location"
            backup_path="$backup_location/$app_name-$backup_timestamp"

            # Move old deployment files to backup location
            mv "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"
            
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi





=========================


#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

# Use unzip with -u option to update existing files
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home"
tar -xf /path/to/your/file.zip -C /path/to/extract


# List files after extraction in the specified path
ls -la "$Profile_home/release/"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    targeted_location="{{ targeted_location }}"
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Backup timestamp
            backup_timestamp=$(date +'%Y%m%d%H%M%S')

            # Construct paths for old deployment files and backup location
            old_deployment_path="$targeted_location/$app_targeted_location"
            backup_path="$backup_location/$app_name-$backup_timestamp"

            # Move old deployment files to backup location
            mv "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"
            
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi


    "stdout_lines": [
        "Profile_home: /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin",
        "zip_file_url: https://maven.pkg.github.com/rakbank-internal/ibps-was-ansible-cd/Rak/IBPS/release/1.0.0/release-1.0.0.zip",
        "zip_file_name: release-1.0.0.zip",
        "/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin",
===============================================

newgenapp_jar.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell
=================================

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

# Use unzip with -u option to update existing files
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home"

# List files after extraction in the specified path
ls -la "$Profile_home/release/"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup and copy deployment files for each application
while IFS=, read -r app_name app_targeted_location; do
    # Check if the app_targeted_location is not empty
    if [ -n "$app_targeted_location" ]; then
        # Backup timestamp
        backup_timestamp=$(date +'%Y%m%d%H%M%S')

        # Construct paths for old deployment files and backup location
        old_deployment_path="$Profile_home/$app_targeted_location"
        backup_path="$backup_location/$app_name-$backup_timestamp"

        # Move old deployment files to backup location
        mv "$old_deployment_path" "$backup_path"

        # Print information about the backup
        echo "Backup: $app_name - $old_deployment_path -> $backup_path"
        
        # Define paths for new deployment files and targeted location
        new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
        targeted_path="$Profile_home/$app_targeted_location"

        # Copy new deployment files to targeted location
        cp -r "$new_deployment_path" "$targeted_path"

        # Print information about the copy
        echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
    fi
done <<< "$release_content"
=========================

strace -f -o strace_output.txt unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home"

cat strace_output.txt

top

htop

#!/bin/bash
Profile_home="$1"
zip_file_name="$2"

echo "Profile_home: $Profile_home"
echo "zip_file_name: $zip_file_name"

# Use strace to trace system calls during the extraction process
strace -f -o strace_output.txt unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home"

# Display the contents of the strace output file
cat strace_output.txt

================
pv "$Profile_home/$zip_file_name" | unzip -u -d "$Profile_home" - && echo "Extraction completed."


rakbank-internal/ibps-was-ansible-cd/.github/workflows/ibps_deployment.yml@refs/heads/dev

release2-1.0.0.zip
newgenapp_jar.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell
==============
release2-1.0.2.zip
ofme_ejb.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell
==================
release2-1.0.3.zip
omniapp_ejb.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell
===========
release2-1.0.4.zip
WFS.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell
=========

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

# Use unzip with -u option to update existing files
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home"

# List files after extraction in the specified path
ls -la "$Profile_home/release/"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    targeted_location="{{ targeted_location }}"
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Backup timestamp
            backup_timestamp=$(date +'%Y%m%d%H%M%S')

            # Construct paths for old deployment files and backup location
            old_deployment_path="$targeted_location/$app_targeted_location"
            backup_path="$backup_location/$app_name-$backup_timestamp"

            # Move old deployment files to backup location
            mv "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"
            
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
===========

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

# Use unzip with -u option to update existing files
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home"

# List files after extraction in the specified path
ls -la "$Profile_home/release/"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Deploy new files for each application
if [ -n "$release_content" ]; then
    targeted_location="{{ targeted_location }}"

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
==============

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

# Use strace to trace system calls during the extraction process
strace -f -o strace_output.txt unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home"

# Display the contents of the strace output file
cat strace_output.txt
===============

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

# Extract release version from the zip file name (assuming the format is release-X.Y.Z.zip)
release_version=$(echo "$zip_file_name" | grep -oP 'release-\K[0-9]+\.[0-9]+\.[0-9]+')
release_dir="release$release_version"

# Use unzip with -u option to update existing files
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home/$release_dir"

# List files after extraction in the specified path
ls -la "$Profile_home/$release_dir"

# Read the content of release.txt
release_content=$(cat "$Profile_home/$release_dir/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Copy deployment files for each application
while IFS=, read -r app_name app_targeted_location; do
    # Check if the app_targeted_location is not empty
    if [ -n "$app_targeted_location" ]; then
        # Define paths for new deployment files and targeted location
        new_deployment_path="$Profile_home/$release_dir/$app_name"  # Assuming the new files are in the release directory
        targeted_path="$Profile_home/$app_targeted_location"

        # Copy new deployment files to targeted location
        cp -r "$new_deployment_path" "$targeted_path"

        # Print information about the copy
        echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
    fi
done <<< "$release_content"
============

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

# Extract release version from the zip file name (assuming the format is release-X.Y.Z.zip)
release_version=$(echo "$zip_file_name" | grep -oP 'release-\K[0-9]+\.[0-9]+\.[0-9]+')
release_dir="release2-$release_version"  # Modify the directory name to release2

# Use unzip with -u option to update existing files
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home/$release_dir"

# List files after extraction in the specified path
ls -la "$Profile_home/$release_dir"

# Read the content of release.txt
release_content=$(cat "$Profile_home/$release_dir/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Copy deployment files for each application
while IFS=, read -r app_name app_targeted_location; do
    # Check if the app_targeted_location is not empty
    if [ -n "$app_targeted_location" ]; then
        # Define paths for new deployment files and targeted location
        new_deployment_path="$Profile_home/$release_dir/$app_name"  # Assuming the new files are in the release directory
        targeted_path="$Profile_home/$app_targeted_location"

        # Copy new deployment files to targeted location
        cp -r "$new_deployment_path" "$targeted_path"

        # Print information about the copy
        echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
    fi
done <<< "$release_content"
==================

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

# Extract release version from the zip file name (assuming the format is release-X.Y.Z.zip)
release_version=$(echo "$zip_file_name" | grep -oP 'release-\K[0-9]+\.[0-9]+\.[0-9]+')
release_dir="release2-$release_version"  # Modify the directory name to release2

# Use unzip with -u option to update existing files
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home/$release_dir"

# List files after extraction in the specified path
ls -la "$Profile_home/$release_dir"

# Read the content of release.txt
release_content=$(cat "$Profile_home/$release_dir/release.txt" 2>/dev/null)

# Print the content of release_content
echo "Release Content: $release_content"

# Copy deployment files for each application
while IFS=, read -r app_name app_targeted_location; do
    # Check if the app_targeted_location is not empty
    if [ -n "$app_targeted_location" ]; then
        echo "Entering the loop"
        # Define paths for new deployment files and targeted location
        new_deployment_path="$Profile_home/$release_dir/$app_name"  # Assuming the new files are in the release directory
        targeted_path="$Profile_home/$app_targeted_location"

        # Print debug messages
        echo "App Name: $app_name"
        echo "App Targeted Location: $app_targeted_location"
        echo "Source Path: $new_deployment_path"
        echo "Target Path: $targeted_path"

        # Check if the source directory exists
        if [ -d "$new_deployment_path" ]; then
            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        else
            echo "Source directory does not exist: $new_deployment_path"
        fi
    fi
done <<< "$release_content"
==================
#!/bin/bash

Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

# Extract release version from the zip file name (assuming the format is release-X.Y.Z.zip)
release_version=$(echo "$zip_file_name" | grep -oP 'release-\K[0-9]+\.[0-9]+\.[0-9]+')
release_dir="release2-$release_version"  # Modify the directory name to release2

# Use unzip with -u option to update existing files
unzip -uq "$Profile_home/$zip_file_name" -d "$Profile_home/$release_dir"

# List files after extraction in the specified path
ls -la "$Profile_home/$release_dir"

# Read the content of release.txt
release_content=$(cat "$Profile_home/$release_dir/release.txt" 2>/dev/null)

# Print the content of release_content
echo "Release Content:"
echo "$release_content"

# Copy deployment files for each application
while IFS=, read -r app_name app_targeted_location; do
    # Check if the app_targeted_location is not empty
    if [ -n "$app_targeted_location" ]; then
        echo "Entering the loop"
        # Define paths for new deployment files and targeted location
        new_deployment_path="$Profile_home/$release_dir/$app_name"  # Assuming the new files are in the release directory
        targeted_path="$Profile_home/$app_targeted_location"

        # Print debug messages
        echo "App Name: $app_name"
        echo "App Targeted Location: $app_targeted_location"
        echo "Source Path: $new_deployment_path"
        echo "Target Path: $targeted_path"

        # Check if the source directory exists
        if [ -d "$new_deployment_path" ]; then
            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        else
            echo "Source directory does not exist: $new_deployment_path"
        fi
    fi
done <<< "$release_content"
