#!/bin/bash

Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

rm -rf "$Profile_home/release"

# Use unzip with -u option to update existing files
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home"

ls -la "$Profile_home/release"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Create a backup directory with a timestamp
    backup_timestamp=$(date +'%Y%m%d%H%M%S')
    backup_directory="$backup_location/backup-$backup_timestamp"
    mkdir -p "$backup_directory"

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if both app_name and app_targeted_location are not empty
        if [ -n "$app_name" ] && [ -n "$app_targeted_location" ]; then
            # Construct paths for old deployment files and backup location
            old_deployment_path="$app_targeted_location"
            backup_path="$backup_directory/$app_name"

            # Copy old deployment files to backup location
            cp -r "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"

            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
======================

#!/bin/bash

Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

# Remove existing release directory
rm -rf "$Profile_home/release"

# Extract the zip file to the release directory
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home"

# List the contents of the release directory
ls -la "$Profile_home/release"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Create a backup directory with a timestamp
    backup_timestamp=$(date +'%Y%m%d%H%M%S')
    backup_directory="$backup_location/backup-$backup_timestamp"
    mkdir -p "$backup_directory"

    # Copy release.txt file into backup directory
    cp "$Profile_home/release/release.txt" "$backup_directory"

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if both app_name and app_targeted_location are not empty
        if [ -n "$app_name" ] && [ -n "$app_targeted_location" ]; then
            # Construct paths for old deployment files and backup location
            old_deployment_path="$app_targeted_location"
            backup_path="$backup_directory/$app_name"

            # Copy old deployment files to backup location
            cp -r "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"

            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            #targeted_path="$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$app_targeted_location"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $app_targeted_location"
        fi
    done <<< "$release_content"
fi
====================

TASK [IBPS-deployment : Run deploy on Target Server] ***************************
task path: /ansible/GITHUB_RUNNER/actions-runner10/_work/ibps-was-ansible-cd/ibps-was-ansible-cd/roles/IBPS-deployment/tasks/main-deploy.yml:24
fatal: [ANT3CASAPPS01]: FAILED! => {
    "msg": "The task includes an option with an undefined variable. The error was: 'targeted_location' is undefined\n\nThe error appears to be in '/ansible/GITHUB_RUNNER/actions-runner10/_work/ibps-was-ansible-cd/ibps-was-ansible-cd/roles/IBPS-deployment/tasks/main-deploy.yml': line 24, column 3, but may\nbe elsewhere in the file depending on the exact syntax problem.\n\nThe offending line appears to be:\n\n\n- name: Run deploy on Target Server\n  ^ here\n"
}
...ignoring
TASK [IBPS-deployment : Run ls -la on the Target Server] ***********************
task path: /ansible/GITHUB_RUNNER/actions-runner10/_work/ibps-was-ansible-cd/ibps-was-ansible-cd/roles/IBPS-deployment/tasks/main-deploy.yml:31
fatal: [ANT3CASAPPS01]: FAILED! => {
    "msg": "The task includes an option with an undefined variable. The error was: 'targeted_location' is undefined\n\nThe error appears to be in '/ansible/GITHUB_RUNNER/actions-runner10/_work/ibps-was-ansible-cd/ibps-was-ansible-cd/roles/IBPS-deployment/tasks/main-deploy.yml': line 31, column 3, but may\nbe elsewhere in the file depending on the exact syntax problem.\n\nThe offending line appears to be:\n\n\n- name: Run ls -la on the Target Server\n  ^ here\n"
}
