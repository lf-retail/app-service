name: IBPS-deployment
on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on:
     group: rakbank-self-hosted-runner
     labels: dehitdevtra1

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Debug Working Directory
      run: |
        ls -al
        pwd
    - name: Make deploy.sh executable
      run: |
        chmod +x deploy.sh #rollback.sh
    - name: Run Ansible Playbook
      env:
        TOKEN_GITHUB: ${{ secrets.TOKEN_GITHUB }}
      run: |
        cd ${{ github.workspace }}
        ansible-playbook -vvv -b --extra-vars "target=target_jb destination=${{ github.workspace }}" ./playbook/IBPS-deployment.yml
        #ansible-playbook -vvv -b --extra-vars "target=target_jb destination=${{ github.workspace }} deploy_mode=false rollback_mode=true" ./playbook/IBPS-deployment.yml
====================================

---
ibps_server: 10.15.13.148:9043
github_token: "{{ lookup('env', 'TOKEN_GITHUB') }}"
zip_file_url: "https://maven.pkg.github.com/rakbank-internal/ibps-was-ansible-cd/Rak/IBPS/release/1.0.0.2/release-1.0.0.2.zip"
zip_file_name: "{{ zip_file_url | basename }}"
Profile_home: "/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin"
targeted_location: "/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell"
ansible_user: "itdevtra"
backup_location: "/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/backup"
...

===========================================================
- name: Download zip from GitHub packages on Runner
  delegate_to: localhost
  run_once: true
  get_url:
    url: "{{ zip_file_url }}"
    dest: "/tmp/{{ zip_file_name }}"
    headers:
      Authorization: "token {{ github_token }}"
 
- name: Copy zip to Target Server
  copy:
    src: "/tmp/{{ zip_file_name }}"
    dest: "{{ Profile_home }}/{{ zip_file_name }}"
    mode: '0755'

- name: Copy deploy.sh to Target Server
  copy:
    src: "/ansible/GITHUB_RUNNER/actions-runner10/_work/ibps-was-ansible-cd/ibps-was-ansible-cd/deploy.sh"
    dest: "{{ Profile_home }}/deploy.sh"
    mode: '0755'
  become: yes
  become_user: "{{ ansible_user }}"

- name: Run deploy on Target Server
  become: yes
  become_user: "{{ ansible_user }}"
  shell: "cd {{ Profile_home }} && ./deploy.sh {{ Profile_home }} {{ zip_file_url }} {{ zip_file_name }} {{ backup_location }}"
  register: deploy_result
  ignore_errors: yes

- name: Run ls -la on the Target Server
  become: true
  become_user: itdevtra
  command: "ls -la {{ targeted_location }}"
  register: ls_result    

- name: Display ls -la result
  debug:
    var: ls_result.stdout_lines   

- name: Clean up zip file from Runner
  delegate_to: localhost
  file:
    path: "/tmp/{{ zip_file_name }}"
    state: absent
  run_once: true   
===================================
- name: Copy rollback.sh to Target Server
  copy:
    src: "/ansible/GITHUB_RUNNER/actions-runner10/_work/ibps-was-ansible-cd/ibps-was-ansible-cd/rollback.sh"
    dest: "{{ Profile_home }}/rollback.sh"
    mode: '0755'
  become: yes
  become_user: "{{ ansible_user }}"

- name: Run deploy on Target Server
  become: yes
  become_user: "{{ ansible_user }}"
  shell: "cd {{ Profile_home }} && ./rollback.sh {{ Profile_home }} {{ backup_location }}"
  register: deploy_result
  ignore_errors: yes

- name: List contents of the directory after copying rollback.sh
  command: ls -al "{{ targeted_location }}"
  become: yes
  become_user: "{{ ansible_user }}"

- name: Clean up zip file from Runner
  delegate_to: localhost
  file:
    path: "/tmp/{{ zip_file_name }}"
    state: absent
  run_once: true   
================
#!/bin/bash

Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home/release"

rm -rf "$Profile_home/release"

# Use unzip with -u option to update existing files
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home"

ls -la "$Profile_home/release"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    targeted_location="$targeted_location"
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Backup timestamp
            backup_timestamp=$(date +'%Y%m%d%H%M%S')

            # Construct paths for old deployment files and backup location
            old_deployment_path="$targeted_location/$app_targeted_location"
            backup_path="$backup_location/$app_name-$backup_timestamp"

            # Move old deployment files to backup location
            mv "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"

            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
=============================================
#!/bin/bash

Profile_home="$1"
backup_location="$2"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Rollback old deployment files for each application based on the latest backup
if [ -n "$release_content" ]; then
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Find the latest backup directory for the current application
            latest_backup=$(ls -td "$backup_location/$app_name-"* | head -n1)

            # Extract the filename from the latest backup directory
            backup_filename=$(basename "$latest_backup")

            # Construct paths for the latest backup files and targeted location
            backup_path="$latest_backup"
            targeted_path="$app_targeted_location/$backup_filename"

            # Copy files from the latest backup to targeted location
            cp -r "$backup_path" "$targeted_path"

            # Print information about the rollback
            echo "Rollback: $app_name - $backup_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
