#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

rm -rf "$Profile_home/release2"

# Use unzip with -u option to update existing files
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home"

# List files after extraction in the specified path
ls -la "$Profile_home/release2/"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release2/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    targeted_location="{{ targeted_location }}"
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Backup timestamp
            backup_timestamp=$(date +'%Y%m%d%H%M%S')

            # Construct paths for old deployment files and backup location
            old_deployment_path="$targeted_location/$app_targeted_location"
            backup_path="$backup_location/$app_name-$backup_timestamp"

            # Move old deployment files to backup location
            mv "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"
            
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release2/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
========================
#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

# Remove the existing release directory if it exists
rm -rf "$Profile_home/release2"

# Use unzip to extract contents into the specified directory
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home/"

# List files after extraction in the specified path
ls -la "$Profile_home/release2"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release2/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Deploy new files for each application
if [ -n "$release_content" ]; then
    targeted_location="{{ targeted_location }}"

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release2/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
================

#!/bin/bash
Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

# Remove the existing release directory if it exists
rm -rf "$Profile_home/release2"

# Use unzip to extract contents into the specified directory
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home/"

# List files after extraction in the specified path
#ls -la "$Profile_home/release2"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release2/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Deploy new files for each application
if [ -n "$release_content" ]; then
    targeted_location="{{ targeted_location }}"

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release2/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
===============

TASK [IBPS-deployment : Run deploy on Target Server] ***************************
task path: /ansible/GITHUB_RUNNER/actions-runner10/_work/ibps-was-ansible-cd/ibps-was-ansible-cd/roles/IBPS-deployment/tasks/main.yml:34
<10.15.13.148> ESTABLISH SSH CONNECTION FOR USER: itdevtra
<10.15.13.148> SSH: EXEC ssh -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o Port=22 -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o 'User="itdevtra"' -o ConnectTimeout=30 -o ControlPath=/home/itdevtra/.ansible/cp/2b6c10444a 10.15.13.148 '/bin/sh -c '"'"'( umask 77 && mkdir -p "` echo /tmp `"&& mkdir /tmp/ansible-tmp-1706691263.022208-3339894-79895053182279 && echo ansible-tmp-1706691263.022208-3339894-79895053182279="` echo /tmp/ansible-tmp-1706691263.022208-3339894-79895053182279 `" ) && sleep 0'"'"''
<10.15.13.148> (0, b'ansible-tmp-1706691263.022208-3339894-79895053182279=/tmp/ansible-tmp-1706691263.022208-3339894-79895053182279\n', b'')
Using module file /usr/lib/python3.6/site-packages/ansible/modules/commands/command.py
<10.15.13.148> PUT /home/itdevtra/.ansible/tmp/ansible-local-33391453jmhl_e7/tmpi2xiomp1 TO /tmp/ansible-tmp-1706691263.022208-3339894-79895053182279/AnsiballZ_command.py
<10.15.13.148> SSH: EXEC sftp -b - -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o Port=22 -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o 'User="itdevtra"' -o ConnectTimeout=30 -o ControlPath=/home/itdevtra/.ansible/cp/2b6c10444a '[10.15.13.148]'
<10.15.13.148> (0, b'sftp> put /home/itdevtra/.ansible/tmp/ansible-local-33391453jmhl_e7/tmpi2xiomp1 /tmp/ansible-tmp-1706691263.022208-3339894-79895053182279/AnsiballZ_command.py\n', b'')
<10.15.13.148> ESTABLISH SSH CONNECTION FOR USER: itdevtra
<10.15.13.148> SSH: EXEC ssh -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o Port=22 -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o 'User="itdevtra"' -o ConnectTimeout=30 -o ControlPath=/home/itdevtra/.ansible/cp/2b6c10444a 10.15.13.148 '/bin/sh -c '"'"'chmod u+x /tmp/ansible-tmp-1706691263.022208-3339894-79895053182279/ /tmp/ansible-tmp-1706691263.022208-3339894-79895053182279/AnsiballZ_command.py && sleep 0'"'"''
<10.15.13.148> (0, b'', b'')
<10.15.13.148> ESTABLISH SSH CONNECTION FOR USER: itdevtra
<10.15.13.148> SSH: EXEC ssh -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o Port=22 -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o 'User="itdevtra"' -o ConnectTimeout=30 -o ControlPath=/home/itdevtra/.ansible/cp/2b6c10444a -tt 10.15.13.148 '/bin/sh -c '"'"'/usr/bin/python /tmp/ansible-tmp-1706691263.022208-3339894-79895053182279/AnsiballZ_command.py && sleep 0'"'"''
<10.15.13.148> (0, b'\r\n{"changed": true, "end": "2024-01-31 12:55:28.257337", "stdout": "Profile_home: /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin\\nzip_file_url: https://maven.pkg.github.com/rakbank-internal/ibps-was-ansible-cd/Rak/IBPS/release2/1.0.1/release2-1.0.1.zip\\nzip_file_name: release2-1.0.1.zip\\nnewgenapp_jar.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r\\nofme_ejb.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r\\nomniapp_ejb.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r\\nWFS.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r\\nCopy: newgenapp_jar.ear - /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release2/newgenapp_jar.ear -> {{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r\\nCopy: ofme_ejb.ear - /ibm/IBM-CAS/WebSphe...
<10.15.13.148> ESTABLISH SSH CONNECTION FOR USER: itdevtra
<10.15.13.148> SSH: EXEC ssh -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o Port=22 -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o 'User="itdevtra"' -o ConnectTimeout=30 -o ControlPath=/home/itdevtra/.ansible/cp/2b6c10444a 10.15.13.148 '/bin/sh -c '"'"'rm -f -r /tmp/ansible-tmp-1706691263.022208-3339894-79895053182279/ > /dev/null 2>&1 && sleep 0'"'"''
<10.15.13.148> (0, b'', b'')
changed: [ANT3CASAPPS01] => {
    "changed": true,
    "cmd": "cd /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin && ./deploy.sh /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin https://maven.pkg.github.com/rakbank-internal/ibps-was-ansible-cd/Rak/IBPS/release2/1.0.1/release2-1.0.1.zip release2-1.0.1.zip /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/backup",
    "delta": "0:00:00.368724",
    "end": "2024-01-31 12:55:28.257337",
    "invocation": {
        "module_args": {
            "_raw_params": "cd /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin && ./deploy.sh /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin https://maven.pkg.github.com/rakbank-internal/ibps-was-ansible-cd/Rak/IBPS/release2/1.0.1/release2-1.0.1.zip release2-1.0.1.zip /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/backup",
            "_uses_shell": true,
            "argv": null,
            "chdir": null,
            "creates": null,
            "executable": null,
            "removes": null,
            "stdin": null,
            "stdin_add_newline": true,
            "strip_empty_ends": true,
            "warn": false
        }
    },
    "rc": 0,
    "start": "2024-01-31 12:55:27.888613",
    "stderr": "cp: cannot create directory ‘{{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r’: No such file or directory\ncp: cannot create directory ‘{{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r’: No such file or directory\ncp: cannot create directory ‘{{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r’: No such file or directory\ncp: cannot create directory ‘{{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r’: No such file or directory",
    "stderr_lines": [
        "cp: cannot create directory ‘{{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r’: No such file or directory",
        "cp: cannot create directory ‘{{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r’: No such file or directory",
        "cp: cannot create directory ‘{{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r’: No such file or directory",
        "cp: cannot create directory ‘{{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\\r’: No such file or directory"
    ],
    "stdout": "Profile_home: /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin\nzip_file_url: https://maven.pkg.github.com/rakbank-internal/ibps-was-ansible-cd/Rak/IBPS/release2/1.0.1/release2-1.0.1.zip\nzip_file_name: release2-1.0.1.zip\nnewgenapp_jar.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\r\nofme_ejb.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\r\nomniapp_ejb.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\r\nWFS.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\r\nCopy: newgenapp_jar.ear - /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release2/newgenapp_jar.ear -> {{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell\r\nCopy: ofme_ejb.ear - /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release2/ofme_ejb.ear -> {{ targeted_location }}//ibm/...
    "stdout_lines": [
        "Profile_home: /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin",
        "zip_file_url: https://maven.pkg.github.com/rakbank-internal/ibps-was-ansible-cd/Rak/IBPS/release2/1.0.1/release2-1.0.1.zip",
        "zip_file_name: release2-1.0.1.zip",
        "newgenapp_jar.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell",
        "ofme_ejb.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell",
        "omniapp_ejb.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell",
        "WFS.ear,/ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell",
        "Copy: newgenapp_jar.ear - /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release2/newgenapp_jar.ear -> {{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell",
        "Copy: ofme_ejb.ear - /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release2/ofme_ejb.ear -> {{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell",
        "Copy: omniapp_ejb.ear - /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release2/omniapp_ejb.ear -> {{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell",
        "Copy: WFS.ear - /ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/bin/release2/WFS.ear -> {{ targeted_location }}//ibm/IBM-CAS/WebSphere/AppServer/profiles/AppSrv01/installedApps/ANT2CASAPPS01Node01Cell"
    ]
}
================
- name: Run deploy on Target Server
  command: "cd {{ profile_home }}/bin && ./deploy.sh {{ profile_home }}/bin {{ zip_file_url }} {{ zip_file_name }} {{ backup_location }}"
  environment:
    targeted_location: "{{ targeted_location }}"
  become: yes
  become_user: "{{ ansible_user }}"
==============
targeted_location="$targeted_location"

# ... (rest of the script)

# Copy new deployment files to targeted location
cp -r "$new_deployment_path" "$targeted_location"

# ... (rest of the script)
===================

- name: Download zip from GitHub packages on Runner
  delegate_to: localhost
  run_once: true
  get_url:
    url: "{{ zip_file_url }}"
    dest: "/tmp/{{ zip_file_name }}"
    headers:
      Authorization: "token {{ github_token }}"
 
- name: Copy zip to Target Server
  copy:
    src: "/tmp/{{ zip_file_name }}"
    dest: "{{ Profile_home }}/{{ zip_file_name }}"
    mode: '0755'

- name: List contents of the directory after copying deploy.sh
  command: ls -al "{{ Profile_home }}"
  become: yes
  become_user: "{{ ansible_user }}"    
    
- name: Copy deploy.sh to Target Server
  copy:
    src: "/ansible/GITHUB_RUNNER/actions-runner10/_work/ibps-was-ansible-cd/ibps-was-ansible-cd/deploy.sh"
    dest: "{{ Profile_home }}/deploy.sh"
    mode: '0755'
  become: yes
  become_user: "{{ ansible_user }}"

- name: List contents of the directory after copying deploy.sh
  command: ls -al "{{ Profile_home }}"
  become: yes
  become_user: "{{ ansible_user }}"

#- name: Run deploy on Target Server
 # become: yes
  #become_user: "{{ ansible_user }}"
  #shell: "cd {{ Profile_home }} && ./deploy.sh {{ Profile_home }} {{ zip_file_url }} {{ zip_file_name }} {{ backup_location }}"
  #register: deploy_result
  #ignore_errors: yes

- name: Run deploy on Target Server
  become: yes
  become_user: "{{ ansible_user }}"
  shell: "cd {{ profile_home }}/bin && ./deploy.sh {{ profile_home }}/bin {{ zip_file_url }} {{ zip_file_name }} {{ backup_location }}"
  environment:
    targeted_location: "{{ targeted_location }}"
  register: deploy_result  
  ignore_errors: yes 

- name: List contents of the directory after copying deploy.sh
  command: ls -al "{{ targeted_location }}"
  become: yes
  become_user: "{{ ansible_user }}"

- name: Clean up zip file from Runner
  delegate_to: localhost
  file:
    path: "/tmp/{{ zip_file_name }}"
    state: absent
  run_once: true   
=====================

- name: Run deploy on Target Server
  become: yes
  become_user: "{{ ansible_user }}"
  shell: "cd {{ profile_home }}/bin && ./deploy.sh {{ profile_home }}/bin {{ zip_file_url }} {{ zip_file_name }} {{ backup_location }}"
  environment:
    targeted_location: "{{ targeted_location }}"
  register: deploy_result  
  ignore_errors: yes 
========

#!/bin/bash

Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

ls -la "$Profile_home"

rm -rf "$Profile_home/release2"

# Use unzip with -u option to update existing files
unzip -q -u "$Profile_home/$zip_file_name" -d "$Profile_home"

# List files after extraction in the specified path
ls -la "$Profile_home/release2/"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release2/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    targeted_location="$targeted_location"
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Backup timestamp
            backup_timestamp=$(date +'%Y%m%d%H%M%S')

            # Construct paths for old deployment files and backup location
            old_deployment_path="$targeted_location/$app_targeted_location"
            backup_path="$backup_location/$app_name-$backup_timestamp"

            # Move old deployment files to backup location
            mv "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"
            
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release2/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
=================
#!/bin/bash

Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

echo "Profile_home: $Profile_home"
echo "zip_file_url: $zip_file_url"
echo "zip_file_name: $zip_file_name"

# Remove the existing release directory if it exists
rm -rf "$Profile_home/release2"

# Use unzip to extract contents into the specified directory
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home/"

# List files after extraction in the specified path
# ls -la "$Profile_home/release2"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release2/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Deploy new files for each application
if [ -n "$release_content" ]; then
    targeted_location="$targeted_location"

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release2/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
=====================

ansible-playbook -vvv -b --extra-vars "target=target_jb destination=${{ github.workspace }}" ./playbook/IBPS-deployment.yml
======

ansible-playbook -vvv -b --extra-vars "target=target_jb destination=${{ github.workspace }} deploy_mode=true rollback_mode=false" ./playbook/IBPS-deployment.yml
===============
---
- name: Main Playbook
  hosts: your_target_hosts
  gather_facts: true

  tasks:
    - name: Include deploy playbook
      import_playbook: main-deploy.yml
      when: deploy_mode | default(false)

    - name: Include rollback playbook
      import_playbook: main-rollback.yml
      when: rollback_mode | default(false)
