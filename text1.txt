#!/bin/bash

Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

rm -rf "$Profile_home/release"

# Use unzip with -u option to update existing files
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home"

ls -la "$Profile_home/release"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Iterate through each line in release_content
while IFS=, read -r app_name app_targeted_location; do
    # Check if both app_name and app_targeted_location are not empty
    if [ -n "$app_name" ] && [ -n "$app_targeted_location" ]; then
        # Define paths for new deployment files and targeted location
        new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
        targeted_path="$app_targeted_location"

        # Copy new deployment files to targeted location
        cp -r "$new_deployment_path" "$targeted_path"

        # Print information about the copy
        echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
    fi
done <<< "$release_content"
======================

#!/bin/bash

Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

rm -rf "$Profile_home/release"

# Use unzip with -u option to update existing files
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home"

ls -la "$Profile_home/release"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Create a backup directory with a timestamp
    backup_timestamp=$(date +'%Y%m%d%H%M%S')
    backup_directory="$backup_location/backup-$backup_timestamp"
    mkdir -p "$backup_directory"

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if both app_name and app_targeted_location are not empty
        if [ -n "$app_name" ] && [ -n "$app_targeted_location" ]; then
            # Construct paths for old deployment files and backup location
            old_deployment_path="$app_targeted_location"
            backup_path="$backup_directory/$app_name"

            # Copy old deployment files to backup location
            cp -r "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"

            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi


in release directory i can see the log

        "drwxrwxr-x 6 itdevtra itdevtra 4096 Feb 15 15:02 .",
        "drwxrwxr-x 3 itdevtra itdevtra 4096 Feb 15 15:02 ..",
        "drwxrwxr-x 3 itdevtra itdevtra 4096 Feb  9 09:22 newgenapp_jar.ear",
        "drwxrwxr-x 3 itdevtra itdevtra 4096 Feb  9 09:22 ofme_ejb.ear",
        "drwxrwxr-x 3 itdevtra itdevtra 4096 Feb  9 09:22 omniapp_ejb.ear",
        "-rw-rw-r-- 1 itdevtra itdevtra  221 Feb 14 15:03 release.txt",
        "drwxrwxr-x 3 itdevtra itdevtra 4096 Feb  9 09:22 WFS.ear",

in release.txt i can see the log

        "newgenapp_jar.ear,/ibm/IBM-CAS/WebSphere/targeted_location",
        "ofme_ejb.ear,/ibm/IBM-CAS/WebSphere/targeted_location",
        "omniapp_ejb.ear,/ibm/IBM-CAS/WebSphere/targeted_location",
        "WFS.ear,/ibm/IBM-CAS/WebSphere/targeted_location",

also its taking backup and copy the new files into targeted location

        "Backup: newgenapp_jar.ear - /ibm/IBM-CAS/WebSphere/targeted_location",
        " -> /ibm/IBM-CAS/WebSphere/backup/backup-20240215150208/newgenapp_jar.ear",
        "Copy: newgenapp_jar.ear - /ibm/IBM-CAS/WebSphere/deploy_script/release/newgenapp_jar.ear -> /ibm/IBM-CAS/WebSphere/targeted_location",
        "Backup: ofme_ejb.ear - /ibm/IBM-CAS/WebSphere/targeted_location",
        " -> /ibm/IBM-CAS/WebSphere/backup/backup-20240215150208/ofme_ejb.ear",
        "Copy: ofme_ejb.ear - /ibm/IBM-CAS/WebSphere/deploy_script/release/ofme_ejb.ear -> /ibm/IBM-CAS/WebSphere/targeted_location",
        "Backup: omniapp_ejb.ear - /ibm/IBM-CAS/WebSphere/targeted_location",
        " -> /ibm/IBM-CAS/WebSphere/backup/backup-20240215150208/omniapp_ejb.ear",
        "Copy: omniapp_ejb.ear - /ibm/IBM-CAS/WebSphere/deploy_script/release/omniapp_ejb.ear -> /ibm/IBM-CAS/WebSphere/targeted_location",
        "Backup: WFS.ear - /ibm/IBM-CAS/WebSphere/targeted_location -> /ibm/IBM-CAS/WebSphere/backup/backup-20240215150208/WFS.ear",
        "Copy: WFS.ear - /ibm/IBM-CAS/WebSphere/deploy_script/release/WFS.ear -> /ibm/IBM-CAS/WebSphere/targeted_location"

====================================

#!/bin/bash

Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

rm -rf "$Profile_home/release"

# Use unzip with -u option to update existing files
unzip -q "$Profile_home/$zip_file_name" -d "$Profile_home"

ls -la "$Profile_home/release"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Create a backup directory with a timestamp
    backup_timestamp=$(date +'%Y%m%d%H%M%S')
    backup_directory="$backup_location/backup-$backup_timestamp"
    mkdir -p "$backup_directory"

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if both app_name and app_targeted_location are not empty
        if [ -n "$app_name" ] && [ -n "$app_targeted_location" ]; then
            # Log the targeted path
            echo "Targeted location for $app_name: $app_targeted_location"

            # Define paths for old deployment files and backup location
            old_deployment_path="$app_targeted_location"
            backup_path="$backup_directory/$app_name"

            # Backup old deployment files to backup location
            cp -r "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"

            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
==================

- name: Download zip from GitHub packages on Runner
  delegate_to: localhost
  run_once: true
  get_url:
    url: "{{ zip_file_url }}"
    dest: "/tmp/{{ zip_file_name }}"
    headers:
      Authorization: "token {{ github_token }}"
 
- name: Copy zip to Target Server
  copy:
    src: "/tmp/{{ zip_file_name }}"
    dest: "{{ Profile_home }}/{{ zip_file_name }}"
    mode: '0755'

- name: Copy deploy.sh to Target Server
  copy:
    src: "/ansible/GITHUB_RUNNER/actions-runner10/_work/ibps-was-ansible-cd/ibps-was-ansible-cd/deploy.sh"
    dest: "{{ Profile_home }}/deploy.sh"
    mode: '0755'
  become: yes
  become_user: "{{ ansible_user }}"

- name: Run deploy on Target Server
  become: yes
  become_user: "{{ ansible_user }}"
  shell: "cd {{ Profile_home }} && ./deploy.sh {{ Profile_home }} {{ zip_file_url }} {{ zip_file_name }} {{ backup_location }}"
  register: deploy_result
  ignore_errors: yes
