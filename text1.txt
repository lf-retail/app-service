#!/bin/bash

Profile_home="$1"
zip_file_url="$2"
zip_file_name="$3"
backup_location="$4"

rm -rf "$Profile_home/release"

# Use unzip with -u option to update existing files
unzip -q -u "$Profile_home/$zip_file_name" -d "$Profile_home"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Print the content of release_content
echo "$release_content"

# Backup old deployment files for each application with timestamp
if [ -n "$release_content" ]; then
    targeted_location="$targeted_location"
    backup_location="$backup_location"  # Use the variable passed from Ansible

    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Backup timestamp
            backup_timestamp=$(date +'%Y%m%d%H%M%S')

            # Construct paths for old deployment files and backup location
            old_deployment_path="$targeted_location/$app_targeted_location"
            backup_path="$backup_location/$app_name-$backup_timestamp"

            # Move old deployment files to backup location
            mv "$old_deployment_path" "$backup_path"

            # Print information about the backup
            echo "Backup: $app_name - $old_deployment_path -> $backup_path"
            
            # Define paths for new deployment files and targeted location
            new_deployment_path="$Profile_home/release/$app_name"  # Assuming the new files are in the release directory
            targeted_path="$targeted_location/$app_targeted_location"

            # Copy new deployment files to targeted location
            cp -r "$new_deployment_path" "$targeted_path"

            # Print information about the copy
            echo "Copy: $app_name - $new_deployment_path -> $targeted_path"
        fi
    done <<< "$release_content"
fi
============
#!/bin/bash

Profile_home="$1"
backup_location="$2"

# Read the content of release.txt
release_content=$(cat "$Profile_home/release/release.txt" 2>/dev/null)

# Rollback old deployment files for each application based on the latest timestamp
if [ -n "$release_content" ]; then
    # Iterate through each line in release_content
    while IFS=, read -r app_name app_targeted_location; do
        # Check if the app_targeted_location is not empty
        if [ -n "$app_targeted_location" ]; then
            # Find the latest backup directory for the application
            latest_backup=$(ls -td "$backup_location/$app_name-"* | head -n 1)

            # Check if a backup directory exists for the application
            if [ -n "$latest_backup" ]; then
                # Define the path for the old deployment files
                old_deployment_path="$latest_backup/$app_name"

                # Define the path for the targeted location
                targeted_path="$app_targeted_location"

                # Copy old deployment files from backup to targeted location
                cp -r "$old_deployment_path" "$targeted_path"

                # Print information about the rollback
                echo "Rollback: $app_name - $old_deployment_path -> $targeted_path"
            else
                echo "No backup found for $app_name."
            fi
        fi
    done <<< "$release_content"
fi
